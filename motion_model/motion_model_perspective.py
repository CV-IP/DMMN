import numpy as np
from .motion_model import MotionModel
from dataset.utils.common import get_cx_cy_w_h
import torch
import warnings
warnings.simplefilter('ignore', np.RankWarning)
from scipy.optimize import curve_fit
from tqdm import trange

class MotionModelPerspective(MotionModel):
    """ Perspective Motion Model :math:`f(t) = (at + b) / (ct + 1)`

    * :math:`x_c(t) = (a_0 t + a_1) / (b_2 t + 1)`
    * :math:`y_c(t) = (b_0 t + b_1) / (b_2 t + 1)`
    * :math:`w_c(t) = (c_0 t + c_1) / (c_2 t + 1)`
    * :math:`h_c(t) = (d_0 t + d_1) / (d_2 t + 1)`
    """

    def __init__(self, parameters=None):
        """
        Init by a parameters, where parameters' shape is (4, 3)
        :param parameters: a parameter whose shape is (4, 3)
        """
        super(MotionModelPerspective, self).__init__(12)
        self.parameters = parameters

    @staticmethod
    def model_func(x, p0, p1, p2):
        return np.log((x*p0 + p1) / (x*p2 + 1))

    @staticmethod
    def model_func_torch(x, p0, p1, p2):
        return torch.log((x*p0 + p1) / (x*p2 + 1))

    def fit(self, bboxes, times=None):
        if times is None:
            times = range(len(bboxes))

        res = get_cx_cy_w_h(bboxes)
        x = times
        parameters = []
        try:
            for y in res:
                parameters += [curve_fit(MotionModelPerspective.model_func, x, np.log(y))[0]]
            self.parameters = np.array(parameters)
        except:
            self.parameters = MotionModelPerspective.get_invalid_params()


        return self.parameters


    def get_bbox_by_frame(self, time):
        cx_cy_w_h = np.array([np.exp(MotionModelPerspective.model_func(time, *p)) for p in self.parameters])
        cx = cx_cy_w_h[0]
        cy = cx_cy_w_h[1]
        w = cx_cy_w_h[2]
        h = cx_cy_w_h[3]
        return np.array([cx - w/2.0, cy - h/2.0, cx + w/2.0, cy + h/2.0])

    def get_bbox_by_frames(self, times):
        """
        Get the bbox by a set of times
        :param times: a set of times with shape (n, ) where n is the length of time
        :return: boxes generated by the parameter and times, i.e. [16, 4] where 16 is the length of time and 4 is the (l, t, r, b)
        """
        cx_cy_w_h = np.array([np.exp(MotionModelPerspective.model_func(times, *p)) for p in self.parameters]).T
        # time_array = np.stack([np.power(times, i) for i in [2, 1, 0]], axis=1)
        # cx_cy_w_h = np.sum(self.parameters * time_array[:, None, :], axis=2)
        # verify the generated box is right or not
        # cx_cy_w_h[np.logical_or(cx_cy_w_h[:, 2] <= 0, cx_cy_w_h[:, 3] <= 0), :] = 0

        cx_cy_w_h[np.sum(np.isnan(cx_cy_w_h), axis=1) > 0, :] = np.zeros((4))

        bbox = np.concatenate([cx_cy_w_h[:, :2] - cx_cy_w_h[:, 2:] / 2., cx_cy_w_h[:, :2] + cx_cy_w_h[:, 2:] / 2.], axis=1)
        return bbox

    @staticmethod
    def get_invalid_params():
        return np.zeros((4, 3))

    @staticmethod
    def get_invalid_box():
        return np.ones((4))

    @staticmethod
    def get_num_parameter():
        return 12

    @staticmethod
    def get_parameters(bboxes, times, invalid_node_rate):
        """
        Get the parameter of boxes.
        :param bboxes: (FrameId, TrackId, 4)
        :param times: Times indexes
        :param invalid_node_rate: the threshold for cacluate the parameters
        :returns: parameters: (TrackId, ParameterData)
                  motion_possibility: (trackId, possibility)

        """
        parameters = list()
        motion_posibility = list()
        frame_num, track_num, _ = bboxes.shape
        mm = MotionModelPerspective()
        for i in range(track_num):
            bbs = bboxes[:, i, :]
            mask = np.sum(bbs, axis=1) > 0
            motion_posibility += [mask]
            if sum(mask) < 5 or sum(mask) / len(mask) <= invalid_node_rate:
                parameters += [MotionModelPerspective.get_invalid_params()]
            else:
                # print(np.sum(mask))
                param = mm.fit(bbs[mask, :], times[mask])
                parameters += [param]
        return np.stack(parameters, axis=0), np.stack(motion_posibility, 1).astype(float)

    @staticmethod
    def get_str(parameters):
        p = parameters[0, :]
        return "x = {:0.2f}t^2+{:0.2f}t+{:0.2f}".format(p[0], p[1], p[2])

    @staticmethod
    def get_bbox_by_frames_pytorch(parameters, times):
        p = parameters[:, None, :, :, :].expand(parameters.shape[0], times.shape[1], *parameters.shape[1:4])
        t = times[:, :, None, None].expand(*times.shape[:2], *p.shape[2:4])
        p0 = p[:, :, :, :, 0]
        p1 = p[:, :, :, :, 1]
        p2 = p[:, :, :, :, 2]

        bboxes = MotionModelPerspective.model_func_torch(t, p0, p1, p2)
        bboxes[torch.isnan(bboxes.sum(dim=3)), :] = 0

        # times_1 = torch.stack([torch.pow(times, 2), torch.pow(times, 1), torch.pow(times, 0)], dim=2)
        # times_1 = times_1.permute([1, 0, 2])[:, :, None, None, :]
        # parameters_1 = torch.sum((parameters * times_1.float()).permute([1, 0, 2, 3, 4]), dim=4)

        return bboxes

    @staticmethod
    def get_bbox_by_frames_without_batch_pytorch(parameter, time):
        p = parameter.expand(time.shape[0], *parameter.shape).float()
        t = time[:, None, None].expand(p.shape[:-1]).float()
        p0 = p[:, :, :, 0]
        p1 = p[:, :, :, 1]
        p2 = p[:, :, :, 2]

        bboxes = MotionModelPerspective.model_func_torch(t, p0, p1, p2)
        bboxes[torch.isnan(bboxes.sum(dim=2)), :] = 0
        bboxes[:, :, 2:].clamp_(min=1e-4, max=2)

        return bboxes

